                num = int(h, 16) % (10**10)
                sid = f"pkg_{domain}_{num}"
                key = (domain, sid)
                item = {
                    "id": sid,
                    "domain": domain,
                    "sequence": seq,
                    "length": int(length),
                    "delta_risk": float(dr),
                    "cost": float(c),
                    "score": float(score),
                    "created_at": now,
                    "updated_at": now,
                    "source": "debug_dataset",
                    "label": int(label),
                }
                # 始终写入 ops_detailed（若无参数网格则用仅 name 的占位）
                item["ops_detailed"] = steps or [{"name": nm} for nm in seq]
                if meta:
                    item.update(meta)
                prev = by_key.get(key)
                if (prev is None) or (float(score) > float(prev.get("score", -1e9))):
                    by_key[key] = item
            except Exception:
                continue

    '# 2) 仅遍历各 dataset_*_<domain> 目录下的 *_operator_packages_labeled.json（不扫描其它路径）
    for ds in out_root.glob("dataset_*_*"):
        for p in ds.rglob("*_operator_packages_labeled.json"):
            try:
                arr = json.loads(p.read_text(encoding="utf-8"))
            except Exception:
                continue
            for it in (arr or []):
                try:
                    domain = str(it.get("domain", "")).lower() or ds.name.split("_")[-1].lower()
                    seq = list(it.get("sequence", []) or [])
                    steps = it.get("ops_detailed") if isinstance(it.get("ops_detailed"), list) else []
                    payload = {"domain": domain, "sequence": list(seq), "ops_detailed": steps or []}
                    sblob = json.dumps(payload, ensure_ascii=False, sort_keys=True, separators=(",", ":")).encode("utf-8")
                    h = hashlib.sha1(sblob).hexdigest()
                    num = int(h, 16) % (10**10)
                    sid = f"pkg_{domain}_{num}"
                    key = (domain, sid)
                    dr = float(it.get("delta_risk", 0.0))
                    c = float(it.get("cost", 0.0))
                    length = int(it.get("length", len(seq)))
                    score = float(it.get("score", dr - cost_lambda * c))
                    now2 = int(it.get("updated_at", now))
                    label = int(it.get("label", 0))
                    meta = {k: it.get(k) for k in ("op_space_id", "op_space_ref") if k in it}
                    validation = it.get("validation", None)
                    if not isinstance(validation, dict):
                        validation = None
                    item = {
                        "id": sid,
                        "domain": domain,
                        "sequence": seq,
                        "length": length,
                        "delta_risk": dr,
                        "cost": c,
                        "score": score,
                        "created_at": int(it.get("created_at", now2)),
                        "updated_at": now2,
                        "source": "labeled_operator_packages",
                        "label": label,
                        "ops_detailed": steps or [{"name": nm} for nm in seq],
                    }
                    if validation:
                        item["validation"] = validation
                    if meta:
                        item.update(meta)
                    prev = by_key.get(key)
                    if (prev is None) or (float(score) > float(prev.get("score", -1e9))):
                        by_key[key] = item
                except Exception:
                    continue'

    # 排序并写入 train_datas/debug_dataset.json
    items = list(by_key.values())
    items.sort(key=lambda d: (
        -float(d.get("score", 0.0)),
        int(d.get("length", 0)),
        tuple(str(x) for x in d.get("sequence", []))
    ))
    out_dir = Path(__file__).resolve().parent
    out_dir.mkdir(parents=True, exist_ok=True)
    out_path = out_dir / "debug_dataset.json"
    out_path.write_text(json.dumps(items, ensure_ascii=False, indent=2), encoding="utf-8")
    print(f"[collect] written: {out_path} items={len(items)}")

    # 同步生成配套统计：debug_dataset.stats.json（针对上述 debug_dataset.json）
    try:
        total = len(items)
        by_domain: Dict[str, int] = {}
        by_label: Dict[str, int] = {"1": 0, "0": 0, "unknown": 0}
        lengths: List[int] = []
        scores: List[float] = []
        risks: List[float] = []
        costs: List[float] = []
        per_domain: Dict[str, Dict[str, Any]] = {}
